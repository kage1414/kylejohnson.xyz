// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kylejohnson-xyz/ent/application"
	"kylejohnson-xyz/ent/description"
	"kylejohnson-xyz/ent/education"
	"kylejohnson-xyz/ent/experience"
	"kylejohnson-xyz/ent/invite"
	"kylejohnson-xyz/ent/predicate"
	"kylejohnson-xyz/ent/technology"
	"kylejohnson-xyz/ent/techstack"
	"kylejohnson-xyz/ent/user"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication = "Application"
	TypeDescription = "Description"
	TypeEducation   = "Education"
	TypeExperience  = "Experience"
	TypeInvite      = "Invite"
	TypeTechStack   = "TechStack"
	TypeTechnology  = "Technology"
	TypeUser        = "User"
)

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	url                 *string
	active              *bool
	priority            *int32
	addpriority         *int32
	clearedFields       map[string]struct{}
	descriptions        map[int]struct{}
	removeddescriptions map[int]struct{}
	cleareddescriptions bool
	technologies        map[int]struct{}
	removedtechnologies map[int]struct{}
	clearedtechnologies bool
	done                bool
	oldValue            func(context.Context) (*Application, error)
	predicates          []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id int) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ApplicationMutation) ClearName() {
	m.name = nil
	m.clearedFields[application.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ApplicationMutation) NameCleared() bool {
	_, ok := m.clearedFields[application.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, application.FieldName)
}

// SetURL sets the "url" field.
func (m *ApplicationMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ApplicationMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ApplicationMutation) ClearURL() {
	m.url = nil
	m.clearedFields[application.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ApplicationMutation) URLCleared() bool {
	_, ok := m.clearedFields[application.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ApplicationMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, application.FieldURL)
}

// SetActive sets the "active" field.
func (m *ApplicationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ApplicationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ClearActive clears the value of the "active" field.
func (m *ApplicationMutation) ClearActive() {
	m.active = nil
	m.clearedFields[application.FieldActive] = struct{}{}
}

// ActiveCleared returns if the "active" field was cleared in this mutation.
func (m *ApplicationMutation) ActiveCleared() bool {
	_, ok := m.clearedFields[application.FieldActive]
	return ok
}

// ResetActive resets all changes to the "active" field.
func (m *ApplicationMutation) ResetActive() {
	m.active = nil
	delete(m.clearedFields, application.FieldActive)
}

// SetPriority sets the "priority" field.
func (m *ApplicationMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ApplicationMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ApplicationMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ApplicationMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *ApplicationMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[application.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *ApplicationMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[application.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *ApplicationMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, application.FieldPriority)
}

// AddDescriptionIDs adds the "descriptions" edge to the Description entity by ids.
func (m *ApplicationMutation) AddDescriptionIDs(ids ...int) {
	if m.descriptions == nil {
		m.descriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.descriptions[ids[i]] = struct{}{}
	}
}

// ClearDescriptions clears the "descriptions" edge to the Description entity.
func (m *ApplicationMutation) ClearDescriptions() {
	m.cleareddescriptions = true
}

// DescriptionsCleared reports if the "descriptions" edge to the Description entity was cleared.
func (m *ApplicationMutation) DescriptionsCleared() bool {
	return m.cleareddescriptions
}

// RemoveDescriptionIDs removes the "descriptions" edge to the Description entity by IDs.
func (m *ApplicationMutation) RemoveDescriptionIDs(ids ...int) {
	if m.removeddescriptions == nil {
		m.removeddescriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.descriptions, ids[i])
		m.removeddescriptions[ids[i]] = struct{}{}
	}
}

// RemovedDescriptions returns the removed IDs of the "descriptions" edge to the Description entity.
func (m *ApplicationMutation) RemovedDescriptionsIDs() (ids []int) {
	for id := range m.removeddescriptions {
		ids = append(ids, id)
	}
	return
}

// DescriptionsIDs returns the "descriptions" edge IDs in the mutation.
func (m *ApplicationMutation) DescriptionsIDs() (ids []int) {
	for id := range m.descriptions {
		ids = append(ids, id)
	}
	return
}

// ResetDescriptions resets all changes to the "descriptions" edge.
func (m *ApplicationMutation) ResetDescriptions() {
	m.descriptions = nil
	m.cleareddescriptions = false
	m.removeddescriptions = nil
}

// AddTechnologyIDs adds the "technologies" edge to the Technology entity by ids.
func (m *ApplicationMutation) AddTechnologyIDs(ids ...int) {
	if m.technologies == nil {
		m.technologies = make(map[int]struct{})
	}
	for i := range ids {
		m.technologies[ids[i]] = struct{}{}
	}
}

// ClearTechnologies clears the "technologies" edge to the Technology entity.
func (m *ApplicationMutation) ClearTechnologies() {
	m.clearedtechnologies = true
}

// TechnologiesCleared reports if the "technologies" edge to the Technology entity was cleared.
func (m *ApplicationMutation) TechnologiesCleared() bool {
	return m.clearedtechnologies
}

// RemoveTechnologyIDs removes the "technologies" edge to the Technology entity by IDs.
func (m *ApplicationMutation) RemoveTechnologyIDs(ids ...int) {
	if m.removedtechnologies == nil {
		m.removedtechnologies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.technologies, ids[i])
		m.removedtechnologies[ids[i]] = struct{}{}
	}
}

// RemovedTechnologies returns the removed IDs of the "technologies" edge to the Technology entity.
func (m *ApplicationMutation) RemovedTechnologiesIDs() (ids []int) {
	for id := range m.removedtechnologies {
		ids = append(ids, id)
	}
	return
}

// TechnologiesIDs returns the "technologies" edge IDs in the mutation.
func (m *ApplicationMutation) TechnologiesIDs() (ids []int) {
	for id := range m.technologies {
		ids = append(ids, id)
	}
	return
}

// ResetTechnologies resets all changes to the "technologies" edge.
func (m *ApplicationMutation) ResetTechnologies() {
	m.technologies = nil
	m.clearedtechnologies = false
	m.removedtechnologies = nil
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	if m.url != nil {
		fields = append(fields, application.FieldURL)
	}
	if m.active != nil {
		fields = append(fields, application.FieldActive)
	}
	if m.priority != nil {
		fields = append(fields, application.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldName:
		return m.Name()
	case application.FieldURL:
		return m.URL()
	case application.FieldActive:
		return m.Active()
	case application.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldName:
		return m.OldName(ctx)
	case application.FieldURL:
		return m.OldURL(ctx)
	case application.FieldActive:
		return m.OldActive(ctx)
	case application.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case application.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case application.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case application.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, application.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case application.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case application.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldName) {
		fields = append(fields, application.FieldName)
	}
	if m.FieldCleared(application.FieldURL) {
		fields = append(fields, application.FieldURL)
	}
	if m.FieldCleared(application.FieldActive) {
		fields = append(fields, application.FieldActive)
	}
	if m.FieldCleared(application.FieldPriority) {
		fields = append(fields, application.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldName:
		m.ClearName()
		return nil
	case application.FieldURL:
		m.ClearURL()
		return nil
	case application.FieldActive:
		m.ClearActive()
		return nil
	case application.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldName:
		m.ResetName()
		return nil
	case application.FieldURL:
		m.ResetURL()
		return nil
	case application.FieldActive:
		m.ResetActive()
		return nil
	case application.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.descriptions != nil {
		edges = append(edges, application.EdgeDescriptions)
	}
	if m.technologies != nil {
		edges = append(edges, application.EdgeTechnologies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeDescriptions:
		ids := make([]ent.Value, 0, len(m.descriptions))
		for id := range m.descriptions {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeTechnologies:
		ids := make([]ent.Value, 0, len(m.technologies))
		for id := range m.technologies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddescriptions != nil {
		edges = append(edges, application.EdgeDescriptions)
	}
	if m.removedtechnologies != nil {
		edges = append(edges, application.EdgeTechnologies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeDescriptions:
		ids := make([]ent.Value, 0, len(m.removeddescriptions))
		for id := range m.removeddescriptions {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeTechnologies:
		ids := make([]ent.Value, 0, len(m.removedtechnologies))
		for id := range m.removedtechnologies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddescriptions {
		edges = append(edges, application.EdgeDescriptions)
	}
	if m.clearedtechnologies {
		edges = append(edges, application.EdgeTechnologies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeDescriptions:
		return m.cleareddescriptions
	case application.EdgeTechnologies:
		return m.clearedtechnologies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeDescriptions:
		m.ResetDescriptions()
		return nil
	case application.EdgeTechnologies:
		m.ResetTechnologies()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// DescriptionMutation represents an operation that mutates the Description nodes in the graph.
type DescriptionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	description        *string
	active             *bool
	priority           *int32
	addpriority        *int32
	clearedFields      map[string]struct{}
	experience         *int
	clearedexperience  bool
	application        *int
	clearedapplication bool
	done               bool
	oldValue           func(context.Context) (*Description, error)
	predicates         []predicate.Description
}

var _ ent.Mutation = (*DescriptionMutation)(nil)

// descriptionOption allows management of the mutation configuration using functional options.
type descriptionOption func(*DescriptionMutation)

// newDescriptionMutation creates new mutation for the Description entity.
func newDescriptionMutation(c config, op Op, opts ...descriptionOption) *DescriptionMutation {
	m := &DescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeDescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDescriptionID sets the ID field of the mutation.
func withDescriptionID(id int) descriptionOption {
	return func(m *DescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Description
		)
		m.oldValue = func(ctx context.Context) (*Description, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Description.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDescription sets the old Description of the mutation.
func withDescription(node *Description) descriptionOption {
	return func(m *DescriptionMutation) {
		m.oldValue = func(context.Context) (*Description, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DescriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Description.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *DescriptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DescriptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Description entity.
// If the Description object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DescriptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DescriptionMutation) ResetDescription() {
	m.description = nil
}

// SetActive sets the "active" field.
func (m *DescriptionMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *DescriptionMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Description entity.
// If the Description object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DescriptionMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ClearActive clears the value of the "active" field.
func (m *DescriptionMutation) ClearActive() {
	m.active = nil
	m.clearedFields[description.FieldActive] = struct{}{}
}

// ActiveCleared returns if the "active" field was cleared in this mutation.
func (m *DescriptionMutation) ActiveCleared() bool {
	_, ok := m.clearedFields[description.FieldActive]
	return ok
}

// ResetActive resets all changes to the "active" field.
func (m *DescriptionMutation) ResetActive() {
	m.active = nil
	delete(m.clearedFields, description.FieldActive)
}

// SetPriority sets the "priority" field.
func (m *DescriptionMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *DescriptionMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Description entity.
// If the Description object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DescriptionMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *DescriptionMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *DescriptionMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *DescriptionMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[description.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *DescriptionMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[description.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *DescriptionMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, description.FieldPriority)
}

// SetExperienceID sets the "experience" edge to the Experience entity by id.
func (m *DescriptionMutation) SetExperienceID(id int) {
	m.experience = &id
}

// ClearExperience clears the "experience" edge to the Experience entity.
func (m *DescriptionMutation) ClearExperience() {
	m.clearedexperience = true
}

// ExperienceCleared reports if the "experience" edge to the Experience entity was cleared.
func (m *DescriptionMutation) ExperienceCleared() bool {
	return m.clearedexperience
}

// ExperienceID returns the "experience" edge ID in the mutation.
func (m *DescriptionMutation) ExperienceID() (id int, exists bool) {
	if m.experience != nil {
		return *m.experience, true
	}
	return
}

// ExperienceIDs returns the "experience" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExperienceID instead. It exists only for internal usage by the builders.
func (m *DescriptionMutation) ExperienceIDs() (ids []int) {
	if id := m.experience; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExperience resets all changes to the "experience" edge.
func (m *DescriptionMutation) ResetExperience() {
	m.experience = nil
	m.clearedexperience = false
}

// SetApplicationID sets the "application" edge to the Application entity by id.
func (m *DescriptionMutation) SetApplicationID(id int) {
	m.application = &id
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *DescriptionMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *DescriptionMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationID returns the "application" edge ID in the mutation.
func (m *DescriptionMutation) ApplicationID() (id int, exists bool) {
	if m.application != nil {
		return *m.application, true
	}
	return
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *DescriptionMutation) ApplicationIDs() (ids []int) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *DescriptionMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// Where appends a list predicates to the DescriptionMutation builder.
func (m *DescriptionMutation) Where(ps ...predicate.Description) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Description, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Description).
func (m *DescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DescriptionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.description != nil {
		fields = append(fields, description.FieldDescription)
	}
	if m.active != nil {
		fields = append(fields, description.FieldActive)
	}
	if m.priority != nil {
		fields = append(fields, description.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case description.FieldDescription:
		return m.Description()
	case description.FieldActive:
		return m.Active()
	case description.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case description.FieldDescription:
		return m.OldDescription(ctx)
	case description.FieldActive:
		return m.OldActive(ctx)
	case description.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Description field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case description.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case description.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case description.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Description field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DescriptionMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, description.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DescriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case description.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case description.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Description numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DescriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(description.FieldActive) {
		fields = append(fields, description.FieldActive)
	}
	if m.FieldCleared(description.FieldPriority) {
		fields = append(fields, description.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DescriptionMutation) ClearField(name string) error {
	switch name {
	case description.FieldActive:
		m.ClearActive()
		return nil
	case description.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown Description nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DescriptionMutation) ResetField(name string) error {
	switch name {
	case description.FieldDescription:
		m.ResetDescription()
		return nil
	case description.FieldActive:
		m.ResetActive()
		return nil
	case description.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Description field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.experience != nil {
		edges = append(edges, description.EdgeExperience)
	}
	if m.application != nil {
		edges = append(edges, description.EdgeApplication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case description.EdgeExperience:
		if id := m.experience; id != nil {
			return []ent.Value{*id}
		}
	case description.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DescriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexperience {
		edges = append(edges, description.EdgeExperience)
	}
	if m.clearedapplication {
		edges = append(edges, description.EdgeApplication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case description.EdgeExperience:
		return m.clearedexperience
	case description.EdgeApplication:
		return m.clearedapplication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DescriptionMutation) ClearEdge(name string) error {
	switch name {
	case description.EdgeExperience:
		m.ClearExperience()
		return nil
	case description.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown Description unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DescriptionMutation) ResetEdge(name string) error {
	switch name {
	case description.EdgeExperience:
		m.ResetExperience()
		return nil
	case description.EdgeApplication:
		m.ResetApplication()
		return nil
	}
	return fmt.Errorf("unknown Description edge %s", name)
}

// EducationMutation represents an operation that mutates the Education nodes in the graph.
type EducationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	school        *string
	time          *string
	certificate   *string
	degree        *string
	active        *bool
	priority      *int32
	addpriority   *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Education, error)
	predicates    []predicate.Education
}

var _ ent.Mutation = (*EducationMutation)(nil)

// educationOption allows management of the mutation configuration using functional options.
type educationOption func(*EducationMutation)

// newEducationMutation creates new mutation for the Education entity.
func newEducationMutation(c config, op Op, opts ...educationOption) *EducationMutation {
	m := &EducationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationID sets the ID field of the mutation.
func withEducationID(id int) educationOption {
	return func(m *EducationMutation) {
		var (
			err   error
			once  sync.Once
			value *Education
		)
		m.oldValue = func(ctx context.Context) (*Education, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Education.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducation sets the old Education of the mutation.
func withEducation(node *Education) educationOption {
	return func(m *EducationMutation) {
		m.oldValue = func(context.Context) (*Education, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Education.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSchool sets the "school" field.
func (m *EducationMutation) SetSchool(s string) {
	m.school = &s
}

// School returns the value of the "school" field in the mutation.
func (m *EducationMutation) School() (r string, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchool returns the old "school" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldSchool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchool: %w", err)
	}
	return oldValue.School, nil
}

// ResetSchool resets all changes to the "school" field.
func (m *EducationMutation) ResetSchool() {
	m.school = nil
}

// SetTime sets the "time" field.
func (m *EducationMutation) SetTime(s string) {
	m.time = &s
}

// Time returns the value of the "time" field in the mutation.
func (m *EducationMutation) Time() (r string, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ClearTime clears the value of the "time" field.
func (m *EducationMutation) ClearTime() {
	m.time = nil
	m.clearedFields[education.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *EducationMutation) TimeCleared() bool {
	_, ok := m.clearedFields[education.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *EducationMutation) ResetTime() {
	m.time = nil
	delete(m.clearedFields, education.FieldTime)
}

// SetCertificate sets the "certificate" field.
func (m *EducationMutation) SetCertificate(s string) {
	m.certificate = &s
}

// Certificate returns the value of the "certificate" field in the mutation.
func (m *EducationMutation) Certificate() (r string, exists bool) {
	v := m.certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificate returns the old "certificate" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldCertificate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificate: %w", err)
	}
	return oldValue.Certificate, nil
}

// ClearCertificate clears the value of the "certificate" field.
func (m *EducationMutation) ClearCertificate() {
	m.certificate = nil
	m.clearedFields[education.FieldCertificate] = struct{}{}
}

// CertificateCleared returns if the "certificate" field was cleared in this mutation.
func (m *EducationMutation) CertificateCleared() bool {
	_, ok := m.clearedFields[education.FieldCertificate]
	return ok
}

// ResetCertificate resets all changes to the "certificate" field.
func (m *EducationMutation) ResetCertificate() {
	m.certificate = nil
	delete(m.clearedFields, education.FieldCertificate)
}

// SetDegree sets the "degree" field.
func (m *EducationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *EducationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ClearDegree clears the value of the "degree" field.
func (m *EducationMutation) ClearDegree() {
	m.degree = nil
	m.clearedFields[education.FieldDegree] = struct{}{}
}

// DegreeCleared returns if the "degree" field was cleared in this mutation.
func (m *EducationMutation) DegreeCleared() bool {
	_, ok := m.clearedFields[education.FieldDegree]
	return ok
}

// ResetDegree resets all changes to the "degree" field.
func (m *EducationMutation) ResetDegree() {
	m.degree = nil
	delete(m.clearedFields, education.FieldDegree)
}

// SetActive sets the "active" field.
func (m *EducationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *EducationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ClearActive clears the value of the "active" field.
func (m *EducationMutation) ClearActive() {
	m.active = nil
	m.clearedFields[education.FieldActive] = struct{}{}
}

// ActiveCleared returns if the "active" field was cleared in this mutation.
func (m *EducationMutation) ActiveCleared() bool {
	_, ok := m.clearedFields[education.FieldActive]
	return ok
}

// ResetActive resets all changes to the "active" field.
func (m *EducationMutation) ResetActive() {
	m.active = nil
	delete(m.clearedFields, education.FieldActive)
}

// SetPriority sets the "priority" field.
func (m *EducationMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *EducationMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *EducationMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *EducationMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *EducationMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[education.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *EducationMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[education.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *EducationMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, education.FieldPriority)
}

// Where appends a list predicates to the EducationMutation builder.
func (m *EducationMutation) Where(ps ...predicate.Education) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Education, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Education).
func (m *EducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.school != nil {
		fields = append(fields, education.FieldSchool)
	}
	if m.time != nil {
		fields = append(fields, education.FieldTime)
	}
	if m.certificate != nil {
		fields = append(fields, education.FieldCertificate)
	}
	if m.degree != nil {
		fields = append(fields, education.FieldDegree)
	}
	if m.active != nil {
		fields = append(fields, education.FieldActive)
	}
	if m.priority != nil {
		fields = append(fields, education.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case education.FieldSchool:
		return m.School()
	case education.FieldTime:
		return m.Time()
	case education.FieldCertificate:
		return m.Certificate()
	case education.FieldDegree:
		return m.Degree()
	case education.FieldActive:
		return m.Active()
	case education.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case education.FieldSchool:
		return m.OldSchool(ctx)
	case education.FieldTime:
		return m.OldTime(ctx)
	case education.FieldCertificate:
		return m.OldCertificate(ctx)
	case education.FieldDegree:
		return m.OldDegree(ctx)
	case education.FieldActive:
		return m.OldActive(ctx)
	case education.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Education field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case education.FieldSchool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchool(v)
		return nil
	case education.FieldTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case education.FieldCertificate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificate(v)
		return nil
	case education.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case education.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case education.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, education.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case education.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case education.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Education numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(education.FieldTime) {
		fields = append(fields, education.FieldTime)
	}
	if m.FieldCleared(education.FieldCertificate) {
		fields = append(fields, education.FieldCertificate)
	}
	if m.FieldCleared(education.FieldDegree) {
		fields = append(fields, education.FieldDegree)
	}
	if m.FieldCleared(education.FieldActive) {
		fields = append(fields, education.FieldActive)
	}
	if m.FieldCleared(education.FieldPriority) {
		fields = append(fields, education.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationMutation) ClearField(name string) error {
	switch name {
	case education.FieldTime:
		m.ClearTime()
		return nil
	case education.FieldCertificate:
		m.ClearCertificate()
		return nil
	case education.FieldDegree:
		m.ClearDegree()
		return nil
	case education.FieldActive:
		m.ClearActive()
		return nil
	case education.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown Education nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationMutation) ResetField(name string) error {
	switch name {
	case education.FieldSchool:
		m.ResetSchool()
		return nil
	case education.FieldTime:
		m.ResetTime()
		return nil
	case education.FieldCertificate:
		m.ResetCertificate()
		return nil
	case education.FieldDegree:
		m.ResetDegree()
		return nil
	case education.FieldActive:
		m.ResetActive()
		return nil
	case education.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Education unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Education edge %s", name)
}

// ExperienceMutation represents an operation that mutates the Experience nodes in the graph.
type ExperienceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	employer            *string
	position            *string
	time                *string
	active              *bool
	priority            *int32
	addpriority         *int32
	clearedFields       map[string]struct{}
	descriptions        map[int]struct{}
	removeddescriptions map[int]struct{}
	cleareddescriptions bool
	done                bool
	oldValue            func(context.Context) (*Experience, error)
	predicates          []predicate.Experience
}

var _ ent.Mutation = (*ExperienceMutation)(nil)

// experienceOption allows management of the mutation configuration using functional options.
type experienceOption func(*ExperienceMutation)

// newExperienceMutation creates new mutation for the Experience entity.
func newExperienceMutation(c config, op Op, opts ...experienceOption) *ExperienceMutation {
	m := &ExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExperienceID sets the ID field of the mutation.
func withExperienceID(id int) experienceOption {
	return func(m *ExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *Experience
		)
		m.oldValue = func(ctx context.Context) (*Experience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Experience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExperience sets the old Experience of the mutation.
func withExperience(node *Experience) experienceOption {
	return func(m *ExperienceMutation) {
		m.oldValue = func(context.Context) (*Experience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Experience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployer sets the "employer" field.
func (m *ExperienceMutation) SetEmployer(s string) {
	m.employer = &s
}

// Employer returns the value of the "employer" field in the mutation.
func (m *ExperienceMutation) Employer() (r string, exists bool) {
	v := m.employer
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployer returns the old "employer" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldEmployer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployer: %w", err)
	}
	return oldValue.Employer, nil
}

// ResetEmployer resets all changes to the "employer" field.
func (m *ExperienceMutation) ResetEmployer() {
	m.employer = nil
}

// SetPosition sets the "position" field.
func (m *ExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *ExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *ExperienceMutation) ResetPosition() {
	m.position = nil
}

// SetTime sets the "time" field.
func (m *ExperienceMutation) SetTime(s string) {
	m.time = &s
}

// Time returns the value of the "time" field in the mutation.
func (m *ExperienceMutation) Time() (r string, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ClearTime clears the value of the "time" field.
func (m *ExperienceMutation) ClearTime() {
	m.time = nil
	m.clearedFields[experience.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *ExperienceMutation) TimeCleared() bool {
	_, ok := m.clearedFields[experience.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *ExperienceMutation) ResetTime() {
	m.time = nil
	delete(m.clearedFields, experience.FieldTime)
}

// SetActive sets the "active" field.
func (m *ExperienceMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ExperienceMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ClearActive clears the value of the "active" field.
func (m *ExperienceMutation) ClearActive() {
	m.active = nil
	m.clearedFields[experience.FieldActive] = struct{}{}
}

// ActiveCleared returns if the "active" field was cleared in this mutation.
func (m *ExperienceMutation) ActiveCleared() bool {
	_, ok := m.clearedFields[experience.FieldActive]
	return ok
}

// ResetActive resets all changes to the "active" field.
func (m *ExperienceMutation) ResetActive() {
	m.active = nil
	delete(m.clearedFields, experience.FieldActive)
}

// SetPriority sets the "priority" field.
func (m *ExperienceMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ExperienceMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ExperienceMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ExperienceMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *ExperienceMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[experience.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *ExperienceMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[experience.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *ExperienceMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, experience.FieldPriority)
}

// AddDescriptionIDs adds the "descriptions" edge to the Description entity by ids.
func (m *ExperienceMutation) AddDescriptionIDs(ids ...int) {
	if m.descriptions == nil {
		m.descriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.descriptions[ids[i]] = struct{}{}
	}
}

// ClearDescriptions clears the "descriptions" edge to the Description entity.
func (m *ExperienceMutation) ClearDescriptions() {
	m.cleareddescriptions = true
}

// DescriptionsCleared reports if the "descriptions" edge to the Description entity was cleared.
func (m *ExperienceMutation) DescriptionsCleared() bool {
	return m.cleareddescriptions
}

// RemoveDescriptionIDs removes the "descriptions" edge to the Description entity by IDs.
func (m *ExperienceMutation) RemoveDescriptionIDs(ids ...int) {
	if m.removeddescriptions == nil {
		m.removeddescriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.descriptions, ids[i])
		m.removeddescriptions[ids[i]] = struct{}{}
	}
}

// RemovedDescriptions returns the removed IDs of the "descriptions" edge to the Description entity.
func (m *ExperienceMutation) RemovedDescriptionsIDs() (ids []int) {
	for id := range m.removeddescriptions {
		ids = append(ids, id)
	}
	return
}

// DescriptionsIDs returns the "descriptions" edge IDs in the mutation.
func (m *ExperienceMutation) DescriptionsIDs() (ids []int) {
	for id := range m.descriptions {
		ids = append(ids, id)
	}
	return
}

// ResetDescriptions resets all changes to the "descriptions" edge.
func (m *ExperienceMutation) ResetDescriptions() {
	m.descriptions = nil
	m.cleareddescriptions = false
	m.removeddescriptions = nil
}

// Where appends a list predicates to the ExperienceMutation builder.
func (m *ExperienceMutation) Where(ps ...predicate.Experience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Experience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Experience).
func (m *ExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExperienceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.employer != nil {
		fields = append(fields, experience.FieldEmployer)
	}
	if m.position != nil {
		fields = append(fields, experience.FieldPosition)
	}
	if m.time != nil {
		fields = append(fields, experience.FieldTime)
	}
	if m.active != nil {
		fields = append(fields, experience.FieldActive)
	}
	if m.priority != nil {
		fields = append(fields, experience.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case experience.FieldEmployer:
		return m.Employer()
	case experience.FieldPosition:
		return m.Position()
	case experience.FieldTime:
		return m.Time()
	case experience.FieldActive:
		return m.Active()
	case experience.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case experience.FieldEmployer:
		return m.OldEmployer(ctx)
	case experience.FieldPosition:
		return m.OldPosition(ctx)
	case experience.FieldTime:
		return m.OldTime(ctx)
	case experience.FieldActive:
		return m.OldActive(ctx)
	case experience.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Experience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case experience.FieldEmployer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployer(v)
		return nil
	case experience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case experience.FieldTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case experience.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case experience.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Experience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExperienceMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, experience.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case experience.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case experience.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Experience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(experience.FieldTime) {
		fields = append(fields, experience.FieldTime)
	}
	if m.FieldCleared(experience.FieldActive) {
		fields = append(fields, experience.FieldActive)
	}
	if m.FieldCleared(experience.FieldPriority) {
		fields = append(fields, experience.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExperienceMutation) ClearField(name string) error {
	switch name {
	case experience.FieldTime:
		m.ClearTime()
		return nil
	case experience.FieldActive:
		m.ClearActive()
		return nil
	case experience.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown Experience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExperienceMutation) ResetField(name string) error {
	switch name {
	case experience.FieldEmployer:
		m.ResetEmployer()
		return nil
	case experience.FieldPosition:
		m.ResetPosition()
		return nil
	case experience.FieldTime:
		m.ResetTime()
		return nil
	case experience.FieldActive:
		m.ResetActive()
		return nil
	case experience.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Experience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.descriptions != nil {
		edges = append(edges, experience.EdgeDescriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case experience.EdgeDescriptions:
		ids := make([]ent.Value, 0, len(m.descriptions))
		for id := range m.descriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddescriptions != nil {
		edges = append(edges, experience.EdgeDescriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExperienceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case experience.EdgeDescriptions:
		ids := make([]ent.Value, 0, len(m.removeddescriptions))
		for id := range m.removeddescriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddescriptions {
		edges = append(edges, experience.EdgeDescriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case experience.EdgeDescriptions:
		return m.cleareddescriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExperienceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Experience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExperienceMutation) ResetEdge(name string) error {
	switch name {
	case experience.EdgeDescriptions:
		m.ResetDescriptions()
		return nil
	}
	return fmt.Errorf("unknown Experience edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	key           *string
	registered    *bool
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Invite, error)
	predicates    []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id int) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *InviteMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *InviteMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *InviteMutation) ResetEmail() {
	m.email = nil
}

// SetKey sets the "key" field.
func (m *InviteMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *InviteMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *InviteMutation) ResetKey() {
	m.key = nil
}

// SetRegistered sets the "registered" field.
func (m *InviteMutation) SetRegistered(b bool) {
	m.registered = &b
}

// Registered returns the value of the "registered" field in the mutation.
func (m *InviteMutation) Registered() (r bool, exists bool) {
	v := m.registered
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistered returns the old "registered" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRegistered(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistered: %w", err)
	}
	return oldValue.Registered, nil
}

// ClearRegistered clears the value of the "registered" field.
func (m *InviteMutation) ClearRegistered() {
	m.registered = nil
	m.clearedFields[invite.FieldRegistered] = struct{}{}
}

// RegisteredCleared returns if the "registered" field was cleared in this mutation.
func (m *InviteMutation) RegisteredCleared() bool {
	_, ok := m.clearedFields[invite.FieldRegistered]
	return ok
}

// ResetRegistered resets all changes to the "registered" field.
func (m *InviteMutation) ResetRegistered() {
	m.registered = nil
	delete(m.clearedFields, invite.FieldRegistered)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *InviteMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *InviteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InviteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *InviteMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InviteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, invite.FieldEmail)
	}
	if m.key != nil {
		fields = append(fields, invite.FieldKey)
	}
	if m.registered != nil {
		fields = append(fields, invite.FieldRegistered)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldEmail:
		return m.Email()
	case invite.FieldKey:
		return m.Key()
	case invite.FieldRegistered:
		return m.Registered()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldEmail:
		return m.OldEmail(ctx)
	case invite.FieldKey:
		return m.OldKey(ctx)
	case invite.FieldRegistered:
		return m.OldRegistered(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case invite.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case invite.FieldRegistered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistered(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invite.FieldRegistered) {
		fields = append(fields, invite.FieldRegistered)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	switch name {
	case invite.FieldRegistered:
		m.ClearRegistered()
		return nil
	}
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldEmail:
		m.ResetEmail()
		return nil
	case invite.FieldKey:
		m.ResetKey()
		return nil
	case invite.FieldRegistered:
		m.ResetRegistered()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, invite.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, invite.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	switch name {
	case invite.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	switch name {
	case invite.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	switch name {
	case invite.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Invite edge %s", name)
}

// TechStackMutation represents an operation that mutates the TechStack nodes in the graph.
type TechStackMutation struct {
	config
	op                Op
	typ               string
	id                *int
	stack             *string
	clearedFields     map[string]struct{}
	technology        map[int]struct{}
	removedtechnology map[int]struct{}
	clearedtechnology bool
	done              bool
	oldValue          func(context.Context) (*TechStack, error)
	predicates        []predicate.TechStack
}

var _ ent.Mutation = (*TechStackMutation)(nil)

// techstackOption allows management of the mutation configuration using functional options.
type techstackOption func(*TechStackMutation)

// newTechStackMutation creates new mutation for the TechStack entity.
func newTechStackMutation(c config, op Op, opts ...techstackOption) *TechStackMutation {
	m := &TechStackMutation{
		config:        c,
		op:            op,
		typ:           TypeTechStack,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechStackID sets the ID field of the mutation.
func withTechStackID(id int) techstackOption {
	return func(m *TechStackMutation) {
		var (
			err   error
			once  sync.Once
			value *TechStack
		)
		m.oldValue = func(ctx context.Context) (*TechStack, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TechStack.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTechStack sets the old TechStack of the mutation.
func withTechStack(node *TechStack) techstackOption {
	return func(m *TechStackMutation) {
		m.oldValue = func(context.Context) (*TechStack, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechStackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechStackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TechStackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TechStackMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TechStack.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStack sets the "stack" field.
func (m *TechStackMutation) SetStack(s string) {
	m.stack = &s
}

// Stack returns the value of the "stack" field in the mutation.
func (m *TechStackMutation) Stack() (r string, exists bool) {
	v := m.stack
	if v == nil {
		return
	}
	return *v, true
}

// OldStack returns the old "stack" field's value of the TechStack entity.
// If the TechStack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechStackMutation) OldStack(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStack: %w", err)
	}
	return oldValue.Stack, nil
}

// ResetStack resets all changes to the "stack" field.
func (m *TechStackMutation) ResetStack() {
	m.stack = nil
}

// AddTechnologyIDs adds the "technology" edge to the Technology entity by ids.
func (m *TechStackMutation) AddTechnologyIDs(ids ...int) {
	if m.technology == nil {
		m.technology = make(map[int]struct{})
	}
	for i := range ids {
		m.technology[ids[i]] = struct{}{}
	}
}

// ClearTechnology clears the "technology" edge to the Technology entity.
func (m *TechStackMutation) ClearTechnology() {
	m.clearedtechnology = true
}

// TechnologyCleared reports if the "technology" edge to the Technology entity was cleared.
func (m *TechStackMutation) TechnologyCleared() bool {
	return m.clearedtechnology
}

// RemoveTechnologyIDs removes the "technology" edge to the Technology entity by IDs.
func (m *TechStackMutation) RemoveTechnologyIDs(ids ...int) {
	if m.removedtechnology == nil {
		m.removedtechnology = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.technology, ids[i])
		m.removedtechnology[ids[i]] = struct{}{}
	}
}

// RemovedTechnology returns the removed IDs of the "technology" edge to the Technology entity.
func (m *TechStackMutation) RemovedTechnologyIDs() (ids []int) {
	for id := range m.removedtechnology {
		ids = append(ids, id)
	}
	return
}

// TechnologyIDs returns the "technology" edge IDs in the mutation.
func (m *TechStackMutation) TechnologyIDs() (ids []int) {
	for id := range m.technology {
		ids = append(ids, id)
	}
	return
}

// ResetTechnology resets all changes to the "technology" edge.
func (m *TechStackMutation) ResetTechnology() {
	m.technology = nil
	m.clearedtechnology = false
	m.removedtechnology = nil
}

// Where appends a list predicates to the TechStackMutation builder.
func (m *TechStackMutation) Where(ps ...predicate.TechStack) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TechStackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TechStackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TechStack, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TechStackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TechStackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TechStack).
func (m *TechStackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TechStackMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.stack != nil {
		fields = append(fields, techstack.FieldStack)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TechStackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case techstack.FieldStack:
		return m.Stack()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TechStackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case techstack.FieldStack:
		return m.OldStack(ctx)
	}
	return nil, fmt.Errorf("unknown TechStack field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechStackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case techstack.FieldStack:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStack(v)
		return nil
	}
	return fmt.Errorf("unknown TechStack field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TechStackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TechStackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechStackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TechStack numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TechStackMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TechStackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechStackMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TechStack nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TechStackMutation) ResetField(name string) error {
	switch name {
	case techstack.FieldStack:
		m.ResetStack()
		return nil
	}
	return fmt.Errorf("unknown TechStack field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TechStackMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.technology != nil {
		edges = append(edges, techstack.EdgeTechnology)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TechStackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case techstack.EdgeTechnology:
		ids := make([]ent.Value, 0, len(m.technology))
		for id := range m.technology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TechStackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtechnology != nil {
		edges = append(edges, techstack.EdgeTechnology)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TechStackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case techstack.EdgeTechnology:
		ids := make([]ent.Value, 0, len(m.removedtechnology))
		for id := range m.removedtechnology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TechStackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtechnology {
		edges = append(edges, techstack.EdgeTechnology)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TechStackMutation) EdgeCleared(name string) bool {
	switch name {
	case techstack.EdgeTechnology:
		return m.clearedtechnology
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TechStackMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TechStack unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TechStackMutation) ResetEdge(name string) error {
	switch name {
	case techstack.EdgeTechnology:
		m.ResetTechnology()
		return nil
	}
	return fmt.Errorf("unknown TechStack edge %s", name)
}

// TechnologyMutation represents an operation that mutates the Technology nodes in the graph.
type TechnologyMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	url                *string
	priority           *int32
	addpriority        *int32
	clearedFields      map[string]struct{}
	application        map[int]struct{}
	removedapplication map[int]struct{}
	clearedapplication bool
	stack              *int
	clearedstack       bool
	done               bool
	oldValue           func(context.Context) (*Technology, error)
	predicates         []predicate.Technology
}

var _ ent.Mutation = (*TechnologyMutation)(nil)

// technologyOption allows management of the mutation configuration using functional options.
type technologyOption func(*TechnologyMutation)

// newTechnologyMutation creates new mutation for the Technology entity.
func newTechnologyMutation(c config, op Op, opts ...technologyOption) *TechnologyMutation {
	m := &TechnologyMutation{
		config:        c,
		op:            op,
		typ:           TypeTechnology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechnologyID sets the ID field of the mutation.
func withTechnologyID(id int) technologyOption {
	return func(m *TechnologyMutation) {
		var (
			err   error
			once  sync.Once
			value *Technology
		)
		m.oldValue = func(ctx context.Context) (*Technology, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Technology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTechnology sets the old Technology of the mutation.
func withTechnology(node *Technology) technologyOption {
	return func(m *TechnologyMutation) {
		m.oldValue = func(context.Context) (*Technology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechnologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechnologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TechnologyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TechnologyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Technology.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TechnologyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TechnologyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TechnologyMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *TechnologyMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *TechnologyMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *TechnologyMutation) ClearURL() {
	m.url = nil
	m.clearedFields[technology.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *TechnologyMutation) URLCleared() bool {
	_, ok := m.clearedFields[technology.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *TechnologyMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, technology.FieldURL)
}

// SetPriority sets the "priority" field.
func (m *TechnologyMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TechnologyMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Technology entity.
// If the Technology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechnologyMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TechnologyMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TechnologyMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *TechnologyMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[technology.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *TechnologyMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[technology.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *TechnologyMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, technology.FieldPriority)
}

// AddApplicationIDs adds the "application" edge to the Application entity by ids.
func (m *TechnologyMutation) AddApplicationIDs(ids ...int) {
	if m.application == nil {
		m.application = make(map[int]struct{})
	}
	for i := range ids {
		m.application[ids[i]] = struct{}{}
	}
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *TechnologyMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *TechnologyMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// RemoveApplicationIDs removes the "application" edge to the Application entity by IDs.
func (m *TechnologyMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplication == nil {
		m.removedapplication = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.application, ids[i])
		m.removedapplication[ids[i]] = struct{}{}
	}
}

// RemovedApplication returns the removed IDs of the "application" edge to the Application entity.
func (m *TechnologyMutation) RemovedApplicationIDs() (ids []int) {
	for id := range m.removedapplication {
		ids = append(ids, id)
	}
	return
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
func (m *TechnologyMutation) ApplicationIDs() (ids []int) {
	for id := range m.application {
		ids = append(ids, id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *TechnologyMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
	m.removedapplication = nil
}

// SetStackID sets the "stack" edge to the TechStack entity by id.
func (m *TechnologyMutation) SetStackID(id int) {
	m.stack = &id
}

// ClearStack clears the "stack" edge to the TechStack entity.
func (m *TechnologyMutation) ClearStack() {
	m.clearedstack = true
}

// StackCleared reports if the "stack" edge to the TechStack entity was cleared.
func (m *TechnologyMutation) StackCleared() bool {
	return m.clearedstack
}

// StackID returns the "stack" edge ID in the mutation.
func (m *TechnologyMutation) StackID() (id int, exists bool) {
	if m.stack != nil {
		return *m.stack, true
	}
	return
}

// StackIDs returns the "stack" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StackID instead. It exists only for internal usage by the builders.
func (m *TechnologyMutation) StackIDs() (ids []int) {
	if id := m.stack; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStack resets all changes to the "stack" edge.
func (m *TechnologyMutation) ResetStack() {
	m.stack = nil
	m.clearedstack = false
}

// Where appends a list predicates to the TechnologyMutation builder.
func (m *TechnologyMutation) Where(ps ...predicate.Technology) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TechnologyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TechnologyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Technology, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TechnologyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TechnologyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Technology).
func (m *TechnologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TechnologyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, technology.FieldName)
	}
	if m.url != nil {
		fields = append(fields, technology.FieldURL)
	}
	if m.priority != nil {
		fields = append(fields, technology.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TechnologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case technology.FieldName:
		return m.Name()
	case technology.FieldURL:
		return m.URL()
	case technology.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TechnologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case technology.FieldName:
		return m.OldName(ctx)
	case technology.FieldURL:
		return m.OldURL(ctx)
	case technology.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Technology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechnologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case technology.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case technology.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case technology.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Technology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TechnologyMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, technology.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TechnologyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case technology.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechnologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case technology.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Technology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TechnologyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(technology.FieldURL) {
		fields = append(fields, technology.FieldURL)
	}
	if m.FieldCleared(technology.FieldPriority) {
		fields = append(fields, technology.FieldPriority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TechnologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechnologyMutation) ClearField(name string) error {
	switch name {
	case technology.FieldURL:
		m.ClearURL()
		return nil
	case technology.FieldPriority:
		m.ClearPriority()
		return nil
	}
	return fmt.Errorf("unknown Technology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TechnologyMutation) ResetField(name string) error {
	switch name {
	case technology.FieldName:
		m.ResetName()
		return nil
	case technology.FieldURL:
		m.ResetURL()
		return nil
	case technology.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Technology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TechnologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.application != nil {
		edges = append(edges, technology.EdgeApplication)
	}
	if m.stack != nil {
		edges = append(edges, technology.EdgeStack)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TechnologyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case technology.EdgeApplication:
		ids := make([]ent.Value, 0, len(m.application))
		for id := range m.application {
			ids = append(ids, id)
		}
		return ids
	case technology.EdgeStack:
		if id := m.stack; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TechnologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapplication != nil {
		edges = append(edges, technology.EdgeApplication)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TechnologyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case technology.EdgeApplication:
		ids := make([]ent.Value, 0, len(m.removedapplication))
		for id := range m.removedapplication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TechnologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplication {
		edges = append(edges, technology.EdgeApplication)
	}
	if m.clearedstack {
		edges = append(edges, technology.EdgeStack)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TechnologyMutation) EdgeCleared(name string) bool {
	switch name {
	case technology.EdgeApplication:
		return m.clearedapplication
	case technology.EdgeStack:
		return m.clearedstack
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TechnologyMutation) ClearEdge(name string) error {
	switch name {
	case technology.EdgeStack:
		m.ClearStack()
		return nil
	}
	return fmt.Errorf("unknown Technology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TechnologyMutation) ResetEdge(name string) error {
	switch name {
	case technology.EdgeApplication:
		m.ResetApplication()
		return nil
	case technology.EdgeStack:
		m.ResetStack()
		return nil
	}
	return fmt.Errorf("unknown Technology edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	email         *string
	hash          *string
	salt          *string
	name          *string
	clearedFields map[string]struct{}
	invite        map[int]struct{}
	removedinvite map[int]struct{}
	clearedinvite bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetHash sets the "hash" field.
func (m *UserMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *UserMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *UserMutation) ResetHash() {
	m.hash = nil
}

// SetSalt sets the "salt" field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// AddInviteIDs adds the "invite" edge to the Invite entity by ids.
func (m *UserMutation) AddInviteIDs(ids ...int) {
	if m.invite == nil {
		m.invite = make(map[int]struct{})
	}
	for i := range ids {
		m.invite[ids[i]] = struct{}{}
	}
}

// ClearInvite clears the "invite" edge to the Invite entity.
func (m *UserMutation) ClearInvite() {
	m.clearedinvite = true
}

// InviteCleared reports if the "invite" edge to the Invite entity was cleared.
func (m *UserMutation) InviteCleared() bool {
	return m.clearedinvite
}

// RemoveInviteIDs removes the "invite" edge to the Invite entity by IDs.
func (m *UserMutation) RemoveInviteIDs(ids ...int) {
	if m.removedinvite == nil {
		m.removedinvite = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invite, ids[i])
		m.removedinvite[ids[i]] = struct{}{}
	}
}

// RemovedInvite returns the removed IDs of the "invite" edge to the Invite entity.
func (m *UserMutation) RemovedInviteIDs() (ids []int) {
	for id := range m.removedinvite {
		ids = append(ids, id)
	}
	return
}

// InviteIDs returns the "invite" edge IDs in the mutation.
func (m *UserMutation) InviteIDs() (ids []int) {
	for id := range m.invite {
		ids = append(ids, id)
	}
	return
}

// ResetInvite resets all changes to the "invite" edge.
func (m *UserMutation) ResetInvite() {
	m.invite = nil
	m.clearedinvite = false
	m.removedinvite = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.hash != nil {
		fields = append(fields, user.FieldHash)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldHash:
		return m.Hash()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldHash:
		return m.OldHash(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldHash:
		m.ResetHash()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.invite != nil {
		edges = append(edges, user.EdgeInvite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInvite:
		ids := make([]ent.Value, 0, len(m.invite))
		for id := range m.invite {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinvite != nil {
		edges = append(edges, user.EdgeInvite)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInvite:
		ids := make([]ent.Value, 0, len(m.removedinvite))
		for id := range m.removedinvite {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinvite {
		edges = append(edges, user.EdgeInvite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeInvite:
		return m.clearedinvite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeInvite:
		m.ResetInvite()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
